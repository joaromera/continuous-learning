# MAKE Documentation notes

## Overview of make

The `make` utility automatically determines which pieces of a large program need to be
recompiled, and issues commands to recompile them.

You can use `make` with any programming language whose compiler can be run with a shell command.

You can use it to describe any task where some files must be _updated automatically_ from others _whenever the others change_.

A file called `makefile` is required, it will describe relationships among the files of our programs while providing commands for updating each one of them.

Tipically, executable file are updated from object files, which are made by compiling source files.

The command `make` will use the makefile data and the last-modification times of the files to decide which of the files need to be updated.

---

## An Introduction to Makefiles

The makefile tells `make` how to compile and link a program.

Makefiles consists of `rules` like the following:

```makefile
target ... : prerequisites ...
    recipe
    ...
    ...
```

`target:` usually the name of a file generated by a program, executable or object files, even name of actions to carry out.

`prerequisite:` files used as input to create the target.

`recipe:` action that `make` carries out. May be more than one command.

_You need to put tabs at the beginning of every recipe line._

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change.

A `rule` that specifies a `recipe` does not need prerequisites.

`Rules` explain how and when to remake certain files which are the targets of a particular rule.

`Make` carries out the recipe on the prerequisites to create or update the target.

Makefiles may contain more text other than rules, but all it needs are rules.

### Example

Make a program `edit` that depends on eight object files, which in turn depend on eight source and three header files.

```makefile
edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

main.o : main.c defs.h
    cc -c main.c

kbd.o : kbd.c defs.h command.h
    cc -c kbd.c

command.o : command.c defs.h command.h
    cc -c command.c

display.o : display.c defs.h buffer.h
    cc -c display.c

insert.o : insert.c defs.h buffer.h
    cc -c insert.c

search.o : search.c defs.h buffer.h
    cc -c search.c

files.o : files.c defs.h buffer.h command.h
    cc -c files.c

utils.o : utils.c defs.h
    cc -c utils.c

clean :
    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
```

When a target is a file it needs to be recompiled or relinked if any of its prerequisites change.

Any prerequisite that is automatically generated needs to be updated first.

A recipe may follow each line that contains a target and prerequisites.

These recipes say how to update the target file.

Tabs distinguish recipes from other lines in the makefile.

`clean` is a target that is not a file and does not have prerequisites. This is a _phony target_.

---

## Makefile processing

Default, `make` starts with the first target (default goal). This can be changed with a special variable.

In the example, the first rule is `edit` and it's a relinking rule, so before it needs to process the rules for the files that `edit` depends on, which are object files.

The rules for each dependant files are processed.

Before recompiling an object file, `make` considers updating its prerequisites (source and header files).

To decide if to relink `edit`, it will check if the file `edit` exists, or if any of the object files is newer than it.

_Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit._

## Variables

To avoid repetition in rules we can use variables.

Standard practice is to have a variable reference objects files with a name such as: objects, OBJECTS, objs, OBJS, etc...

To use this variable we use the string `$(objects)`.

```makefile
objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)

...

clean :
    rm edit $(objects)
```

## Recipes deduced by make

There are implicit rules for updating some files.

It can update an `.o` file from a corresondingly named `.c` file.

When doing so the `.c` files are automatically used and added to the list of prerequisites.

Then we can omit the `.c` file if we omit the recipe.

```makefile
...

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h buffer.h

...

.PHONY : clean
clean :
    rm edit $(objects)
```

If the objects of a makefile are created only by implicit rules you can group entries by their prerequisites instead of by their targets:


```makefile
objects = same as before...

edit : $(objects)
    cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

Next 2.7

