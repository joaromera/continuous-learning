# MAKE Documentation notes

## Overview of make

The `make` utility automatically determines which pieces of a large program need to be
recompiled, and issues commands to recompile them.

You can use `make` with any programming language whose compiler can be run with a shell command.

You can use it to describe any task where some files must be _updated automatically_ from others _whenever the others change_.

A file called `makefile` is required, it will describe relationships among the files of our programs while providing commands for updating each one of them.

Tipically, executable file are updated from object files, which are made by compiling source files.

The command `make` will use the makefile data and the last-modification times of the files to decide which of the files need to be updated.

---

## An Introduction to Makefiles

The makefile tells `make` how to compile and link a program.

Makefiles consists of `rules` like the following:

```makefile
target ... : prerequisites ...
    recipe
    ...
    ...
```

`target:` usually the name of a file generated by a program, executable or object files, even name of actions to carry out.

`prerequisite:` files used as input to create the target.

`recipe:` action that `make` carries out. May be more than one command.

_You need to put tabs at the beginning of every recipe line._

Usually a recipe is in a rule with prerequisites and serves to create a target file if any of the prerequisites change.

A `rule` that specifies a `recipe` does not need prerequisites.

`Rules` explain how and when to remake certain files which are the targets of a particular rule.

`Make` carries out the recipe on the prerequisites to create or update the target.

Makefiles may contain more text other than rules, but all it needs are rules.

### Example

Make a program `edit` that depends on eight object files, which in turn depend on eight source and three header files.

```makefile
edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o

main.o : main.c defs.h
    cc -c main.c

kbd.o : kbd.c defs.h command.h
    cc -c kbd.c

command.o : command.c defs.h command.h
    cc -c command.c

display.o : display.c defs.h buffer.h
    cc -c display.c

insert.o : insert.c defs.h buffer.h
    cc -c insert.c

search.o : search.c defs.h buffer.h
    cc -c search.c

files.o : files.c defs.h buffer.h command.h
    cc -c files.c

utils.o : utils.c defs.h
    cc -c utils.c

clean :
    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o
```

When a target is a file it needs to be recompiled or relinked if any of its prerequisites change.

Any prerequisite that is automatically generated needs to be updated first.

A recipe may follow each line that contains a target and prerequisites.

These recipes say how to update the target file.

Tabs distinguish recipes from other lines in the makefile.

`clean` is a target that is not a file and does not have prerequisites. This is a _phony target_.

---

## Makefile processing

Default, `make` starts with the first target (default goal). This can be changed with a special variable.

In the example, the first rule is `edit` and it's a relinking rule, so before it needs to process the rules for the files that `edit` depends on, which are object files.

The rules for each dependant files are processed.

Before recompiling an object file, `make` considers updating its prerequisites (source and header files).

To decide if to relink `edit`, it will check if the file `edit` exists, or if any of the object files is newer than it.

_Thus, if we change the file insert.c and run make, make will compile that file to update insert.o, and then link edit. If we change the file command.h and run make, make will recompile the object files kbd.o, command.o and files.o and then link the file edit._

## Variables

To avoid repetition in rules we can use variables.

Standard practice is to have a variable reference objects files with a name such as: objects, OBJECTS, objs, OBJS, etc...

To use this variable we use the string `$(objects)`.

```makefile
objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

edit : $(objects)
    cc -o edit $(objects)

...

clean :
    rm edit $(objects)
```

## Recipes deduced by make

There are implicit rules for updating some files.

It can update an `.o` file from a corresondingly named `.c` file.

When doing so the `.c` files are automatically used and added to the list of prerequisites.

Then we can omit the `.c` file if we omit the recipe.

```makefile
...

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h buffer.h

...

.PHONY : clean
clean :
    rm edit $(objects)
```

If the objects of a makefile are created only by implicit rules you can group entries by their prerequisites instead of by their targets:


```makefile
objects = same as before...

edit : $(objects)
    cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
```

## Cleaning the directory

Use `.PHONY` to prevent interpreting `clean` as a file.

```makefile
.PHONY : clean
clean :
    -rm edit $(objects)
```

We don't want it to run by default, so it shouldn't go at the beginning.

---

## 3 Writing makefiles

`Makefiles` contain five kind of things:

* _explicit rules_. Says when and how to remake one or more files (`targets`). It lists other files that the targets depend on (`prerequisites`).
* _implicit rules_. When and how to remake classes of files based on their names.
* _variable definitions_. Specifies a text string value for a variable.
* _directives_. Special instructions:
    * Read another makefile
    * Decide whether to use or ignore a part of the makefile
    * Define a variable from a verbatim string containing multiple lines
* _comments_. They start with `#`. Applies to the whole line unless it ends with `\`. Within a recipe are passed to the shell.

### Special splitting of lines

```makefile
var := one$\
       word
```

Is equivalent to:

```makefile
var := oneword
```

## Makefile names

`make` looks for:

* GNUmakefile
* makefile
* Makefile

For other names:

> $ make -f name

or

> $ make --file=name

You can specify several makefiles if you use more than one `-f` or `--file`.

## Including makefles

The `include` directive tells make to suspend reading the current makefile and read one or more other makefiles before continuing. When that is finished make resumes reading the makefile. Can include shell file name patterns.

If you have three .mk files, _a.mk, b.mk, and c.mk_, and _$(bar)_ expands to _bish bash_ then:

```makefile
include foo *.mk $(bar)
```

Is equivalent to:

```makefile
include foo a.mk b.mk c.mk bin bash
```

Can be used when several programs are handled by individual makefiles in various directories but share variable definitions or pattern rules. Also when you want to generate prerequisites from source files automatically.

If the file name doesn't start with a slash and is not found in the current directory, others will be searched. First any included with the option `-I` or `--include-dir`. Then the following in this order:

* prefix/include (usually _/usr/local/include_)
* /usr/gnu/include
* /usr/local/include
* /usr/include

If the file can't be found a warning will be issued but make will continue. Once it has finished reading makefiles it will try again, only then it will fail with a fatal error.

This error can be ignored with `-include filenames`. The warning will also be ignored.

## Variable MAKEFILES

If the variable is defined then its contents are treated as a list of makefiles preceeded by the `include` directive.

## How `make` reads a makefile

First phase:

1. First it reads all the makefiles
2. It internalizes all the variables, implicit and explicit rules.
3. It builds a dependency graph of all the targets and their prerequisites.

Second phase:

* Using the internalized data it determines which targets need to be updated and run the recipes necessary to do it.

Expansion is _immediate_ if it happens during the first phase. Otherwise is _deferred_.

Deferred expansions are delayed until it is used.

Conditional directives are parsed immediately.

Rules are always expended as:

```makefile
immediate : immediate ; deferred
    deferred
```

Meaning, target and prerequisites sections are expanded immediately. The recipe is always deferred.

---

## How Makefiles are parsed

GNU make parses line by line.

1. Read a line, including backslash-escaped lines
2. Remove comments
3. If the line begins with the recipe prefix character and we are in a rule context, adds the line to the current recipe
4. Expand elements of the line which appear in an _immediate_ expansion context
5. Scan the line for a separator character to determine if is a macro or a rule
6. Internalize the resulting operation and read the next line

One consequence is that a macro can expand to a rule if it is one line long.

## Secondary expansions

Occurs if the special `.SECONDEXPANSION` target is defined.

It must be defined before the first prerequisite list that uses it.

If defined the it will happen at the end of the read-in phase and all the prerequisites of its targets are expanded a _second time_.

Secondary expansion occurs for both expicit and implicit pattern rules.

```makefile
.SECONDEXPANSION:
main_OBJS := main.o try.o test.o
lib_OBJS := lib.o api.o

main lib: $$($$@_OBJS)
```

After the initial expansion prerequisites of both `main` and `lib` targets will be `$($@_OBJS)`.

_(The first $ is escaped)_.

During secondary expansion, `$@` variable is set to the name of the target, so the expansion for main yields `$(main_OBJS)`, or `main.o try.o test.o`.

The secondary of the lib target yields `$(lib_OBJS)`, or `lib.o api.o`.

### Secondary expansion of explicit rules

During secondary expansion of explicit rules:

`$$@` and `$$%` evaluate to the file name of the target.

`$$<` evaluates to the first prerequisite in the first rule for this target.

`$$^` and `$$+` evaluate to the list of all prerequisites of rules _that have already appeared for the same target_.

### For implicit rules

...

---
